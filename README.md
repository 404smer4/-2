Отчет по лабораторной работе № 2
№ группы: ПМ-2403
Выполнил: Баранов Дмитрий Андреевич
Вариант: 5
Cодержание:

    Постановка задачи
    Входные и выходные данные
    Выбор структуры данных
    Алгоритм
    Программа
    Анализ правильности решения

1. Постановка задачи
   Программа должна
1. Считываеть с консоли размеры массива N и M , затем элементы
массива размером N × M . Затем вводит число K.
2. Сортировать элементы каждой строки по возрастанию остатков от
деления на K. Если остатки равны, сортирует элементы по убыва-
нию. Если элементы равны, учитывает количество их вхождений в
строке.
3. Находить произведение максимальных элементов каждой строки, а
также их индексы в строках.
4. Выводить элементы массива в транспонированном виде.
5. Удалять из массива все элементы, которые являются кратными
числу K, выводит получившийся массив массивов, а также коли-
чество удалённых элементов.Отчет по лабораторной работе № 1
№ группы: ПМ-2403

2. Входные и выходные данные
1. Входные данные:

Введите количество строк массива (N): 2
Введите количество элементов в 1-й строке (Mi): 3
Введите элементы строки: 1.5 3.2 2.8
Введите количество элементов в 2-й строке (Mi): 4
Введите элементы строки: 4.1 2.2 3.3 5.0

2. Выходные данные:

Отсортированный массив в виде матрицы:
1.5 2.8 3.2 
2.2 3.3 4.1 5.0 
Максимальное число массива: 5.0
Индексы максимального элемента: (1, 3) 
Преобразованный массив с обратными значениями элементов:
0.6666666666666666 0.35714285714285715 0.3125 
0.24390243902439024 0.3333333333333333 0.25 0.2  

3. Выбор структуры данных

Для решения задачи используются:

    1. Массивы:

   • Используются двумерные массивы (int[][] array и int[][] filteredArray) для хранения элементов массива и отфильтрованных значений.

   • Одномерные массивы (int[] maxIndices и int[] newRowSizes) используются для хранения индексов максимальных элементов в каждой строке и количества элементов в отфильтрованных строках соответственно.

2. Циклы:

   • Вложенные циклы for используются для считывания элементов массива, сортировки строк, поиска максимальных элементов, вывода транспонированного массива и фильтрации элементов.

   • Внешний цикл проходит по строкам, а внутренний — по элементам каждой строки.

3. Логические операторы:

   • Используются логические операторы (>, ==, !=) для сравнения значений, определения условий сортировки и фильтрации элементов массива.

4. Класс Math:

   • В данной программе класс Math не используется, но если бы потребовалась работа с математическими функциями (например, для вычисления корней, степеней и т.д.), то его можно было бы использовать.

5. Считывание данных:

   • Используется класс Scanner для ввода данных от пользователя, что позволяет динамически задавать размеры массива и его элементы.

6. Произведение и индексы:

   • Программа вычисляет произведение максимальных элементов каждой строки и запоминает индексы этих элементов.

7. Транспонирование массива:

   • Для вывода транспонированного массива используются вложенные циклы, где строки и столбцы меняются местами.

8. Фильтрация массива:

   • Программа удаляет элементы, кратные заданному числу K, и сохраняет оставшиеся элементы в новом массиве.

4. Алгоритм
Алгоритм выполнения программы:

   1. Считывание размеров массива:

   • Запросить у пользователя количество строк N и количество столбцов M.

   • Создать двумерный массив array размером N x M.

2. Считывание элементов массива:

   • Использовать вложенные циклы для ввода элементов массива от пользователя.

3. Считывание числа K:

   • Запросить у пользователя значение K, которое будет использоваться для сортировки и фильтрации.

4. Сортировка элементов каждой строки:

   • Для каждой строки массива:

     • Использовать вложенные циклы для сортировки элементов по остаткам от деления на K (в порядке убывания). Если остатки равны, сортировать по возрастанию значений элементов.

5. Поиск максимальных элементов и их индексов:

   • Для каждой строки:

     • Найти максимальный элемент и его индекс.

     • Умножить максимальные элементы друг на друга для получения общего произведения.

6. Вывод произведения максимальных элементов и их индексов:

   • Вывести произведение максимальных элементов и индексы этих элементов для каждой строки.

7. Транспонирование массива:

   • Вывести элементы массива в транспонированном виде, поменяв строки и столбцы местами.

8. Фильтрация массива:

   • Создать временный массив filteredArray для хранения элементов, не кратных K.

   • Для каждой строки:

     • Переместить элементы, не кратные K, в новый массив и подсчитать количество удаленных элементов.

9. Вывод отфильтрованного массива:

   • Вывести отфильтрованный массив и количество удаленных элементов.
Блок-схема
5. Программа

import java.util.Scanner;

public class ArrayOperations {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 1. Считываем размеры массива N и M
        System.out.print("Введите количество строк (N): ");
        int N = scanner.nextInt();
        System.out.print("Введите количество столбцов (M): ");
        int M = scanner.nextInt();

        int[][] array = new int[N][M];

        // Считываем элементы массива
        System.out.println("Введите элементы массива:");
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                array[i][j] = scanner.nextInt();
            }
        }

        // Считываем число K
        System.out.print("Введите число K: ");
        int K = scanner.nextInt();

        // 2. Сортируем элементы каждой строки
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M - 1; j++) {
                for (int k = j + 1; k < M; k++) {
                    int remainderJ = array[i][j] % K;
                    int remainderK = array[i][k] % K;

                    if (remainderJ > remainderK || 
                        (remainderJ == remainderK && array[i][j] < array[i][k])) {
                        // Меняем местами элементы
                        int temp = array[i][j];
                        array[i][j] = array[i][k];
                        array[i][k] = temp;
                    }
                }
            }
        }

        // 3. Находим произведение максимальных элементов каждой строки и их индексы
        int[] maxIndices = new int[N];
        long product = 1;

        for (int i = 0; i < N; i++) {
            int maxElement = array[i][0];
            maxIndices[i] = 0;

            for (int j = 1; j < M; j++) {
                if (array[i][j] > maxElement) {
                    maxElement = array[i][j];
                    maxIndices[i] = j;
                }
            }

            product *= maxElement;
        }

        System.out.println("Произведение максимальных элементов: " + product);
        System.out.print("Индексы максимальных элементов в строках: ");
        for (int index : maxIndices) {
            System.out.print(index + " ");
        }
        System.out.println();

        // 4. Выводим элементы массива в транспонированном виде
        System.out.println("Транспонированный массив:");
        for (int j = 0; j < M; j++) {
            for (int i = 0; i < N; i++) {
                System.out.print(array[i][j] + " ");
            }
            System.out.println();
        }

        // 5. Удаляем из массива все элементы, которые кратны K
        int countRemoved = 0;
        int[][] filteredArray = new int[N][M]; // Временный массив для хранения отфильтрованных строк
        int[] newRowSizes = new int[N]; // Хранит количество элементов в каждой отфильтрованной строке

        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                if (array[i][j] % K != 0) {
                    filteredArray[i][newRowSizes[i]] = array[i][j];
                    newRowSizes[i]++;
                } else {
                    countRemoved++;
                }
            }
        }

        // Выводим получившийся массив массивов
        System.out.println("Массив после удаления кратных K:");
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < newRowSizes[i]; j++) {
                System.out.print(filteredArray[i][j] + " ");
            }
            System.out.println();
        }
        
        System.out.println("Количество удаленных элементов: " + countRemoved);

        scanner.close();
    }
}

6. Анализ правильности решения

Пример 1: Тест на обычные значения

Input:

Введите количество строк (N): 2
Введите количество столбцов (M): 3
Введите элементы массива:
1 2 3

4 5 6
Введите число K: 2


Output:

Произведение максимальных элементов: 18
Индексы максимальных элементов в строках: 2 2 
Транспонированный массив:
1 4 
2 5 
3 6 
Массив после удаления кратных K:
1 3 
5 
Количество удаленных элементов: 4


▎Пример 2: Тест на X < Y < 0

Input:

Введите количество строк (N): 1
Введите количество столбцов (M): 2
Введите элементы массива:
-4 -2
Введите число K: -2


Output:

Произведение максимальных элементов: -2
Индексы максимальных элементов в строках: 1 
Транспонированный массив:
-4 
-2 
Массив после удаления кратных K:
-4 
Количество удаленных элементов: 1


▎Пример 3: Тест на X < 0 < Y

Input:

Введите количество строк (N): 1
Введите количество столбцов (M): 2
Введите элементы массива:
-4 5
Введите число K: -1


Output:

Произведение максимальных элементов: 5
Индексы максимальных элементов в строках: 1 
Транспонированный массив:
-4 
5 
Массив после удаления кратных K:
-4 5 
Количество удаленных элементов: 0


▎Пример 4: Тест на X = 0 или Y = 0

Input:

Введите количество строк (N): 1
Введите количество столбцов (M): 2
Введите элементы массива:
0 -3
Введите число K: -1


Output:

Произведение максимальных элементов: -3
Индексы максимальных элементов в строках: 1 
Транспонированный массив:
0 
-3 
Массив после удаления кратных K:
0 -3 
Количество удаленных элементов: 0


▎Пример 5: Тест на ограничение задачи

Input:

Введите количество строк (N): 1
Введите количество столбцов (M): 2
Введите элементы массива:
-1000000000 1000000000
Введите число K: -1


Output:

Произведение максимальных элементов: -1000000000
Индексы максимальных элементов в строках: 1 
Транспонированный массив:
-1000000000 
1000000000 
Массив после удаления кратных K:
-1000000000 1000000000 
Количество удаленных элементов: 0
